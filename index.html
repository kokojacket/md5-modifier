<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>视频文件 MD5 修改器</title>
    <style>
        :root {
            /* 主题色 */
            --primary-50: #E3F2FD;
            --primary-100: #BBDEFB;
            --primary-200: #90CAF9;
            --primary-300: #64B5F6;
            --primary-400: #42A5F5;
            --primary-500: #2196F3;
            --primary-600: #1E88E5;
            --primary-700: #1976D2;
            --primary-800: #1565C0;
            --primary-900: #0D47A1;

            /* 成功状态色 */
            --success-50: #E8F5E9;
            --success-500: #4CAF50;
            --success-700: #388E3C;

            /* 错误状态色 */
            --error-50: #FFEBEE;
            --error-500: #F44336;
            --error-700: #D32F2F;

            /* 警告状态色 */
            --warning-50: #FFF3E0;
            --warning-500: #FF9800;
            --warning-700: #F57C00;

            /* 中性色 */
            --neutral-50: #FAFAFA;
            --neutral-100: #F5F5F5;
            --neutral-200: #EEEEEE;
            --neutral-300: #E0E0E0;
            --neutral-400: #BDBDBD;
            --neutral-500: #9E9E9E;
            --neutral-600: #757575;
            --neutral-700: #616161;
            --neutral-800: #424242;
            --neutral-900: #212121;

            /* 间距 */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;

            /* 圆角 */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 16px;

            /* 阴影 */
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 15px rgba(0,0,0,0.1);

            /* 动画 */
            --transition-fast: 0.2s ease;
            --transition-normal: 0.3s ease;
            --transition-slow: 0.5s ease;

            /* 字体 */
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --font-size-xs: 12px;
            --font-size-sm: 14px;
            --font-size-md: 16px;
            --font-size-lg: 18px;
            --font-size-xl: 24px;

            /* 新增状态色变量 */
            --success-100: #C8E6C9;
            --error-100: #FFCDD2;
            --warning-100: #FFE0B2;
        }

        /* 重置样式 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            font-size: var(--font-size-md);
            line-height: 1.6;
            color: var(--neutral-900);
            background: var(--neutral-100);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: var(--spacing-xl);
        }

        .card {
            background: white;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            padding: var(--spacing-xl);
            margin-bottom: var(--spacing-xl);
        }

        /* 标题样式 */
        h1 {
            font-size: var(--font-size-xl);
            font-weight: 600;
            color: var(--neutral-900);
            text-align: center;
            margin-bottom: var(--spacing-xl);
        }

        h2 {
            font-size: var(--font-size-lg);
            font-weight: 500;
            color: var(--neutral-800);
            margin-bottom: var(--spacing-md);
        }

        /* 按钮基础样式 */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-sm) var(--spacing-lg);
            border-radius: var(--radius-sm);
            font-size: var(--font-size-md);
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: all var(--transition-fast);
            gap: var(--spacing-sm);
            color: white;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* 按钮变体 */
        .btn-primary {
            background: var(--primary-500);
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-600);
        }

        .btn-success {
            background: var(--success-500);
        }

        .btn-success:hover:not(:disabled) {
            background: var(--success-700);
        }

        .btn-error {
            background: var(--error-500);
        }

        .btn-error:hover:not(:disabled) {
            background: var(--error-700);
        }

        .settings-panel {
            background: white;
            padding: var(--spacing-xl);
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--shadow-sm);
        }

        .settings-panel h2 {
            font-size: var(--font-size-lg);
            font-weight: 500;
            color: var(--neutral-800);
            margin-bottom: var(--spacing-md);
        }

        .suffix-input {
            margin-bottom: var(--spacing-lg);
        }

        .suffix-input label {
            display: block;
            margin-bottom: var(--spacing-xs);
            color: var(--neutral-700);
            font-size: var(--font-size-sm);
        }

        .suffix-input input {
            width: 100%;
            max-width: 300px;
            padding: var(--spacing-sm) var(--spacing-md);
            border: 1px solid var(--neutral-300);
            border-radius: var(--radius-sm);
            font-size: var(--font-size-md);
            transition: all var(--transition-fast);
        }

        .suffix-input input:focus {
            outline: none;
            border-color: var(--primary-500);
            box-shadow: 0 0 0 3px var(--primary-100);
        }

        .directory-input {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            flex-wrap: wrap;
        }

        .selected-dir {
            color: var(--neutral-600);
            font-size: var(--font-size-sm);
            padding: var(--spacing-xs) var(--spacing-sm);
            background: var(--neutral-100);
            border-radius: var(--radius-sm);
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* 拖放区域 */
        .drop-zone {
            border: 2px dashed var(--neutral-300);
            border-radius: var(--radius-lg);
            padding: var(--spacing-xl) var(--spacing-lg);
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-normal);
            background: white;
            margin-bottom: var(--spacing-xl);
        }

        .drop-zone:hover {
            border-color: var(--primary-500);
            background: var(--primary-50);
        }

        .drop-zone.drag-over {
            border-color: var(--primary-500);
            background: var(--primary-50);
            transform: scale(1.02);
        }

        /* 文件列表 */
        .file-list {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-lg);
            border: 1px solid var(--neutral-200);
            border-radius: var(--radius-md);
            background: white;
            transition: all var(--transition-normal);
        }

        .file-item:hover {
            border-color: var(--primary-200);
            box-shadow: var(--shadow-sm);
        }

        .file-info {
            flex: 1;
            min-width: 0;
        }

        .file-name {
            font-weight: 500;
            color: var(--neutral-900);
            margin-bottom: var(--spacing-xs);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-size {
            font-size: var(--font-size-sm);
            color: var(--neutral-600);
        }

        .md5-info {
            font-family: monospace;
            font-size: var(--font-size-sm);
            color: var(--neutral-700);
            margin-top: var(--spacing-sm);
            background: var(--neutral-50);
            padding: var(--spacing-sm);
            border-radius: var(--radius-sm);
            word-break: break-all;
        }

        .file-actions {
            display: flex;
            gap: var(--spacing-sm);
            margin-left: var(--spacing-md);
        }

        /* 进度条 */
        .progress {
            height: 6px;
            background: var(--neutral-100);
            border-radius: var(--radius-sm);
            overflow: hidden;
            margin-top: var(--spacing-sm);
        }

        .progress-bar {
            height: 100%;
            background: var(--primary-500);
            width: 0;
            transition: width var(--transition-normal);
        }

        .status {
            font-size: var(--font-size-sm);
            color: var(--neutral-600);
            margin-top: var(--spacing-sm);
        }

        /* Toast 通知 */
        .toast-container {
            position: fixed;
            top: var(--spacing-lg);
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-sm);
            pointer-events: none;
        }

        .toast {
            background: var(--neutral-800);
            color: white;
            padding: var(--spacing-md) var(--spacing-xl);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            opacity: 0;
            transform: translateY(-20px);
            animation: toastIn var(--transition-normal) forwards;
            max-width: 400px;
            text-align: center;
            pointer-events: auto;
        }

        .toast.success {
            background: var(--success-500);
        }

        .toast.error {
            background: var(--error-500);
        }

        .toast.info {
            background: var(--primary-500);
        }

        @keyframes toastIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes toastOut {
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        /* 全局状态面板 */
        .global-status-panel {
            background: white;
            border: 1px solid var(--neutral-200);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            margin: var(--spacing-xl) 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .global-status-panel::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 4px;
        }

        .global-status-panel.processing {
            background: var(--primary-50);
            border-color: var(--primary-100);
        }

        .global-status-panel.success {
            background: var(--success-50);
            border-color: var(--success-100);
        }

        .global-status-panel.error {
            background: var(--error-50);
            border-color: var(--error-100);
        }

        .global-status-panel.processing::before {
            background: var(--primary-500);
        }

        .global-status-panel.success::before {
            background: var(--success-500);
        }

        .global-status-panel.error::before {
            background: var(--error-500);
        }

        .global-status-panel .status-text {
            flex: 1;
            padding-left: var(--spacing-md);
        }

        .global-status-panel .status-message {
            font-weight: 500;
            color: var(--neutral-900);
            font-size: var(--font-size-md);
            margin-bottom: var(--spacing-xs);
        }

        .global-status-panel .status-info {
            font-size: var(--font-size-sm);
            color: var(--neutral-600);
        }

        .global-status-panel .status-counter {
            font-size: var(--font-size-sm);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-sm);
            min-width: 80px;
            text-align: center;
            background: var(--neutral-100);
            color: var(--neutral-700);
        }

        .global-status-panel.processing .status-counter {
            background: var(--primary-100);
            color: var(--primary-700);
        }

        .global-status-panel.success .status-counter {
            background: var(--success-100);
            color: var(--success-700);
        }

        .global-status-panel.error .status-counter {
            background: var(--error-100);
            color: var(--error-700);
        }

        /* 下载进度覆盖层 */
        .download-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        .download-overlay-content {
            background: white;
            border-radius: var(--radius-lg);
            padding: var(--spacing-xl);
            width: 90%;
            max-width: 500px;
            box-shadow: var(--shadow-lg);
        }

        .download-overlay-title {
            font-size: var(--font-size-lg);
            font-weight: 600;
            color: var(--neutral-900);
            margin-bottom: var(--spacing-md);
            text-align: center;
        }

        .download-overlay-subtitle {
            font-size: var(--font-size-md);
            color: var(--neutral-600);
            margin-bottom: var(--spacing-lg);
            text-align: center;
        }

        .download-progress-bar {
            height: 8px;
            background: var(--neutral-100);
            border-radius: var(--radius-sm);
            margin: var(--spacing-lg) 0;
            overflow: hidden;
        }

        .download-progress-bar-inner {
            height: 100%;
            background: var(--primary-500);
            width: 0;
            transition: width var(--transition-normal);
        }

        .download-counter {
            font-size: var(--font-size-lg);
            font-weight: 600;
            color: var(--primary-500);
            text-align: center;
            margin: var(--spacing-md) 0;
        }

        .download-file-info {
            font-size: var(--font-size-sm);
            color: var(--neutral-600);
            text-align: center;
            margin: var(--spacing-md) 0;
            padding: var(--spacing-sm);
            background: var(--neutral-50);
            border-radius: var(--radius-sm);
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .container {
                padding: var(--spacing-md);
            }
            
            .file-item {
                flex-direction: column;
                gap: var(--spacing-md);
            }
            
            .file-actions {
                width: 100%;
                justify-content: flex-end;
                margin-left: 0;
            }
            
            .directory-input {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .selected-dir {
                max-width: 100%;
            }
            
            .download-overlay-content {
                padding: var(--spacing-lg);
            }
        }

        .button-group {
            display: flex;
            gap: var(--spacing-md);
            margin: var(--spacing-lg) 0;
            justify-content: flex-end;
        }

        .drop-zone p {
            margin: 0;
            font-size: var(--font-size-md);
            color: var(--neutral-600);
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(33, 150, 243, 0); }
            100% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0); }
        }
        
        .global-status-panel.processing {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <h1>视频文件 MD5 修改器</h1>
            
            <div class="settings-panel">
                <h2>设置</h2>
                <div class="suffix-input">
                    <label for="customSuffix">自定义后缀：</label>
                    <input type="text" id="customSuffix" placeholder="例如: -new" value="-new">
                </div>
                <div class="directory-input">
                    <button class="btn btn-primary" onclick="selectSaveDirectory()">选择保存目录</button>
                    <span id="selectedDirPath" class="selected-dir">未选择目录</span>
                </div>
            </div>

            <div id="globalStatusPanel" class="global-status-panel" style="display: none;">
                <div class="status-text">
                    <div id="globalStatusMessage" class="status-message">准备就绪</div>
                    <div id="globalStatusInfo" class="status-info"></div>
                </div>
                <div id="globalStatusCounter" class="status-counter" style="display: none;">
                    0/0 完成
                </div>
            </div>

            <div class="drop-zone" id="dropZone">
                <p>拖放文件到此处或点击选择文件</p>
                <input type="file" id="fileInput" multiple accept=".mp4,.avi,.mkv,.mov" style="display: none">
            </div>
            
            <div class="button-group">
                <button id="downloadAllBtn" class="btn btn-success" disabled onclick="downloadAllFiles()">
                    <span>下载全部</span>
                </button>
                <button id="clearAllBtn" class="btn btn-error" onclick="clearAllFiles()">
                    <span>删除所有</span>
                </button>
            </div>
            
            <div class="file-list" id="fileList"></div>
        </div>
    </div>

    <div class="toast-container" id="toastContainer"></div>

    <div class="download-overlay" id="downloadOverlay">
        <div class="download-overlay-content">
            <div class="download-overlay-title">批量下载进行中</div>
            <div class="download-overlay-subtitle" id="downloadOverlaySubtitle">正在处理文件...</div>

            <div class="download-progress-bar">
                <div class="download-progress-bar-inner" id="downloadProgressBar"></div>
            </div>

            <div class="download-counter" id="downloadCounter">0/0</div>
            <div class="download-file-info" id="downloadFileInfo">准备中...</div>

            <button class="btn btn-primary" id="downloadOverlayClose" onclick="hideDownloadOverlay()">关闭</button>
        </div>
    </div>

    <script>
        const ALLOWED_EXTENSIONS = ['.mp4', '.avi', '.mkv', '.mov'];
        const files = new Map();
        let selectedDirHandle = null;

        // 尝试恢复之前的目录句柄
        async function tryRestoreDirectoryHandle() {
            try {
                // 检查是否支持File System Access API
                if (!('showDirectoryPicker' in window) || !('indexedDB' in window)) {
                    return false;
                }

                // 尝试从IndexedDB获取保存的目录句柄
                const dirHandle = await getSavedDirectoryHandle();
                if (!dirHandle) {
                    return false;
                }

                try {
                    // 请求权限
                    const permission = await dirHandle.requestPermission({ mode: 'readwrite' });
                    if (permission === 'granted') {
                        selectedDirHandle = dirHandle;
                        
                        // 更新UI显示选中的目录
                        const pathSpan = document.getElementById('selectedDirPath');
                        pathSpan.textContent = dirHandle.name;
                        pathSpan.title = `已选择目录: ${dirHandle.name}`;
                        showToast(`已恢复保存目录: ${dirHandle.name}`, 'success');
                        return true;
                    }
                } catch (permErr) {
                    console.error('请求目录权限失败:', permErr);
                }
                
                // 如果恢复失败，清除保存的句柄
                clearSavedDirectoryHandle();
                return false;
            } catch (err) {
                console.error('恢复目录句柄时出错:', err);
                return false;
            }
        }

        // 使用IndexedDB存储目录句柄
        async function saveDirectoryHandle(dirHandle) {
            return new Promise((resolve, reject) => {
                try {
                    if (!dirHandle) {
                        resolve(false);
                        return;
                    }

                    const request = indexedDB.open('MD5ModifierDB', 1);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('handles')) {
                            db.createObjectStore('handles', { keyPath: 'id' });
                        }
                    };
                    
                    request.onsuccess = (event) => {
                        const db = event.target.result;
                        const transaction = db.transaction(['handles'], 'readwrite');
                        const store = transaction.objectStore('handles');
                        
                        const storeRequest = store.put({
                            id: 'saveDir',
                            handle: dirHandle
                        });
                        
                        storeRequest.onsuccess = () => resolve(true);
                        storeRequest.onerror = () => {
                            console.error("存储目录句柄失败");
                            resolve(false);
                        };
                    };
                    
                    request.onerror = (event) => {
                        console.error("打开数据库失败:", event.target.error);
                        resolve(false);
                    };
                } catch (err) {
                    console.error('保存目录句柄失败:', err);
                    resolve(false);
                }
            });
        }

        // 从IndexedDB获取保存的目录句柄
        async function getSavedDirectoryHandle() {
            return new Promise((resolve, reject) => {
                try {
                    const request = indexedDB.open('MD5ModifierDB', 1);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('handles')) {
                            db.createObjectStore('handles', { keyPath: 'id' });
                        }
                    };
                    
                    request.onsuccess = (event) => {
                        const db = event.target.result;
                        try {
                            const transaction = db.transaction(['handles'], 'readonly');
                            const store = transaction.objectStore('handles');
                            
                            const getRequest = store.get('saveDir');
                            
                            getRequest.onsuccess = () => {
                                if (getRequest.result) {
                                    resolve(getRequest.result.handle);
                                } else {
                                    resolve(null);
                                }
                            };
                            
                            getRequest.onerror = () => {
                                console.error("获取目录句柄失败");
                                resolve(null);
                            };
                        } catch (txError) {
                            console.error("事务错误:", txError);
                            resolve(null);
                        }
                    };
                    
                    request.onerror = (event) => {
                        console.error("打开数据库失败:", event.target.error);
                        resolve(null);
                    };
                } catch (err) {
                    console.error('获取目录句柄失败:', err);
                    resolve(null);
                }
            });
        }

        // 清除保存的目录句柄
        async function clearSavedDirectoryHandle() {
            return new Promise((resolve) => {
                try {
                    const request = indexedDB.open('MD5ModifierDB', 1);
                    
                    request.onsuccess = (event) => {
                        const db = event.target.result;
                        const transaction = db.transaction(['handles'], 'readwrite');
                        const store = transaction.objectStore('handles');
                        
                        const deleteRequest = store.delete('saveDir');
                        
                        deleteRequest.onsuccess = () => resolve(true);
                        deleteRequest.onerror = () => {
                            console.error("删除目录句柄失败");
                            resolve(false);
                        };
                    };
                    
                    request.onerror = () => {
                        console.error("打开数据库失败");
                        resolve(false);
                    };
                } catch (err) {
                    console.error('清除目录句柄失败:', err);
                    resolve(false);
                }
            });
        }

        // 选择保存目录
        async function selectSaveDirectory() {
            try {
                if (!('showDirectoryPicker' in window)) {
                    showToast('你的浏览器不支持选择目录功能，文件将保存到默认下载位置', 'error');
                    return;
                }

                const dirHandle = await window.showDirectoryPicker({
                    mode: 'readwrite',
                    // 添加可选的提示信息
                    id: 'md5ModifierSaveDir',
                    startIn: 'downloads'
                });
                selectedDirHandle = dirHandle;
                
                // 更新UI显示选中的目录
                const pathSpan = document.getElementById('selectedDirPath');
                pathSpan.textContent = dirHandle.name;
                pathSpan.title = `已选择目录: ${dirHandle.name}`;
                showToast(`已成功选择保存目录: ${dirHandle.name}`, 'success');
                
                // 保存目录句柄
                await saveDirectoryHandle(dirHandle);
            } catch (err) {
                if (err.name === 'AbortError') {
                    showToast('用户取消了目录选择', 'error');
                } else {
                    console.error('选择目录失败:', err);
                    showToast('选择目录失败: ' + err.message, 'error');
                }
            }
        }

        // 显示提示框
        function showToast(message, type = 'success') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            container.appendChild(toast);

            // 3秒后自动消失
            setTimeout(() => {
                toast.style.animation = 'toastOut var(--transition-normal) forwards';
                setTimeout(() => container.removeChild(toast), 300);
            }, 3000);

            // 同时更新全局状态面板(如果是重要消息)
            if (type === 'success' || type === 'error') {
                updateGlobalStatus(message, type);
            }
        }

        // 更新全局状态面板
        function updateGlobalStatus(message, type = 'info', processing = false, details = '', completed = null, total = null) {
            const panel = document.getElementById('globalStatusPanel');
            const statusMessage = document.getElementById('globalStatusMessage');
            const statusInfo = document.getElementById('globalStatusInfo');
            const statusCounter = document.getElementById('globalStatusCounter');
            
            // 显示面板
            panel.style.display = 'flex';
            
            // 更新样式
            panel.className = 'global-status-panel';
            panel.classList.add(type);
            if (processing) {
                panel.classList.add('processing');
            }
            
            // 更新消息
            statusMessage.textContent = message;
            statusInfo.textContent = details;
            
            // 更新计数器
            if (completed !== null && total !== null) {
                statusCounter.style.display = 'block';
                statusCounter.textContent = `${completed}/${total} 完成`;
            } else {
                statusCounter.style.display = 'none';
            }
        }

        // 清除全局状态
        function clearGlobalStatus() {
            const panel = document.getElementById('globalStatusPanel');
            panel.style.display = 'none';
        }

        // 修改保存文件到指定目录的函数
        async function saveFileToDirectory(fileData, fileName) {
            if (!selectedDirHandle) {
                return false;
            }

            try {
                updateGlobalStatus(`正在保存到目录: ${fileName}`, 'info', true, `目标目录: ${selectedDirHandle.name}`);
                const fileHandle = await selectedDirHandle.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(fileData);
                await writable.close();
                showToast(`文件 ${fileName} 已保存到 ${selectedDirHandle.name}`);
                updateGlobalStatus(`文件已保存: ${fileName}`, 'success', false, `保存在目录: ${selectedDirHandle.name}`);
                return true;
            } catch (err) {
                console.error('保存文件失败:', err);
                showToast(`保存文件 ${fileName} 失败: ${err.message}`, 'error');
                updateGlobalStatus(`保存失败: ${fileName}`, 'error', false, err.message);
                return false;
            }
        }

        // 修改初始化函数
        function initializeEvents() {
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');

            dropZone.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                handleFiles(Array.from(e.dataTransfer.files));
            });
        }

        // 处理文件选择
        function handleFileSelect(e) {
            handleFiles(Array.from(e.target.files));
            e.target.value = ''; // 重置input以允许选择相同文件
        }

        // 处理文件
        async function handleFiles(fileList) {
            // 更新全局状态
            updateGlobalStatus('准备处理文件...', 'info', true, `队列中: ${fileList.length} 个文件`, 0, fileList.length);

            let completedCount = 0;
            
            for (const file of fileList) {
                // 检查文件类型
                const ext = '.' + file.name.split('.').pop().toLowerCase();
                if (!ALLOWED_EXTENSIONS.includes(ext)) {
                    alert(`不支持的文件类型: ${file.name}`);
                    continue;
                }

                const fileId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                files.set(fileId, {
                    file,
                    status: 'pending',
                    originalMd5: null,
                    newMd5: null
                });

                addFileToList(fileId, file.name);
                await processFile(fileId);
                
                // 更新计数器
                completedCount++;
                updateGlobalStatus(
                    completedCount === fileList.length ? '所有文件处理完成' : `正在处理文件...`,
                    completedCount === fileList.length ? 'success' : 'info',
                    completedCount !== fileList.length,
                    `已完成: ${completedCount}/${fileList.length}`,
                    completedCount,
                    fileList.length
                );
            }
        }

        // 添加文件到列表
        function addFileToList(fileId, fileName) {
            const fileList = document.getElementById('fileList');
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            fileItem.id = `file-${fileId}`;
            
            // 获取文件大小
            const fileInfo = files.get(fileId);
            const fileSizeMB = (fileInfo.file.size / (1024 * 1024)).toFixed(2);
            const fileSizeGB = (fileInfo.file.size / (1024 * 1024 * 1024)).toFixed(2);
            
            // 显示合适的文件大小单位
            const sizeDisplay = fileSizeMB > 1024 ? `${fileSizeGB} GB` : `${fileSizeMB} MB`;
            
            fileItem.innerHTML = `
                <div class="file-info">
                    <div class="file-name">${fileName}</div>
                    <div class="file-size">${sizeDisplay}</div>
                    <div class="md5-info"></div>
                    <div class="progress">
                        <div class="progress-bar" id="progress-${fileId}"></div>
                    </div>
                    <div class="status" id="status-${fileId}">准备处理...</div>
                </div>
                <div class="file-actions">
                    <button onclick="downloadFile('${fileId}')" disabled class="btn btn-primary">下载</button>
                    <button onclick="removeFile('${fileId}')" class="btn btn-error">删除</button>
                </div>
            `;
            fileList.appendChild(fileItem);
            
            // 如果文件非常大，显示警告
            if (fileInfo.file.size > 2 * 1024 * 1024 * 1024) { // 大于2GB
                const statusEl = document.getElementById(`status-${fileId}`);
                statusEl.textContent = `注意: 文件较大 (${sizeDisplay})，处理可能需要较长时间`;
                statusEl.style.color = 'var(--warning-500)';
            }
        }

        // 删除单个文件
        function removeFile(fileId) {
            // 从文件Map中删除
            files.delete(fileId);
            
            // 从DOM中删除
            const fileElement = document.getElementById(`file-${fileId}`);
            if (fileElement) {
                fileElement.remove();
            }
            
            // 更新下载全部按钮状态
            updateDownloadAllButton();
        }

        // 检查是否有完成的文件并更新下载全部按钮状态
        function updateDownloadAllButton() {
            const hasCompletedFiles = Array.from(files.values()).some(
                fileInfo => fileInfo.status === 'completed'
            );
            document.getElementById('downloadAllBtn').disabled = !hasCompletedFiles;
        }

        // 处理单个文件
        async function processFile(fileId) {
            const fileInfo = files.get(fileId);
            const statusEl = document.getElementById(`status-${fileId}`);
            const md5InfoEl = document.querySelector(`#file-${fileId} .md5-info`);
            const progressBar = document.getElementById(`progress-${fileId}`);
            
            try {
                // 显示文件大小
                const fileSizeMB = (fileInfo.file.size / (1024 * 1024)).toFixed(2);
                const fileSizeGB = (fileInfo.file.size / (1024 * 1024 * 1024)).toFixed(2);
                const sizeDisplay = fileSizeMB > 1024 ? `${fileSizeGB} GB` : `${fileSizeMB} MB`;
                
                // 更新全局状态面板
                updateGlobalStatus(`正在处理: ${fileInfo.file.name}`, 'info', true, `文件大小: ${sizeDisplay}`);
                
                // 如果文件非常大，显示特殊提示
                if (fileInfo.file.size > 2 * 1024 * 1024 * 1024) {
                    statusEl.textContent = `准备处理大文件 (${sizeDisplay})，请耐心等待...`;
                    statusEl.style.color = 'var(--warning-500)';
                } else {
                    statusEl.textContent = `准备处理文件 (${sizeDisplay})...`;
                    statusEl.style.color = '';
                }
                
                progressBar.style.width = '10%';
                
                // 计算原始MD5
                statusEl.textContent = `计算原始MD5 (${sizeDisplay})...`;
                updateGlobalStatus(`计算原始MD5: ${fileInfo.file.name}`, 'info', true, `文件大小: ${sizeDisplay}`);
                progressBar.style.width = '30%';
                const originalMd5 = await calculateMd5(fileInfo.file);
                fileInfo.originalMd5 = originalMd5;
                
                // 修改文件并计算新MD5
                statusEl.textContent = `修改文件 (${sizeDisplay})...`;
                updateGlobalStatus(`修改文件: ${fileInfo.file.name}`, 'info', true, `文件大小: ${sizeDisplay}`);
                progressBar.style.width = '60%';
                
                try {
                    const modifiedFile = await modifyFile(fileInfo.file);
                    progressBar.style.width = '80%';
                    
                    statusEl.textContent = `计算新MD5 (${sizeDisplay})...`;
                    updateGlobalStatus(`计算新MD5: ${fileInfo.file.name}`, 'info', true, `文件大小: ${sizeDisplay}`);
                    const newMd5 = await calculateMd5(modifiedFile);
                    
                    fileInfo.newMd5 = newMd5;
                    fileInfo.modifiedFile = modifiedFile;
                    fileInfo.status = 'completed';

                    // 更新界面
                    md5InfoEl.innerHTML = `
                        原始MD5: ${originalMd5}<br>
                        新的MD5: ${newMd5}
                    `;
                    statusEl.textContent = '处理完成';
                    statusEl.style.color = 'var(--success-500)';
                    document.querySelector(`#file-${fileId} .btn-primary`).disabled = false;
                    progressBar.style.width = '100%';
                    
                    // 更新全局状态面板
                    updateGlobalStatus(`${fileInfo.file.name} 处理完成`, 'success', false, `可以下载或继续添加文件`);

                    // 更新下载全部按钮状态
                    updateDownloadAllButton();
                } catch (modifyError) {
                    console.error('修改文件时出错:', modifyError);
                    updateGlobalStatus(`修改文件 ${fileInfo.file.name} 失败`, 'error', false, modifyError.message);
                    throw new Error(`修改文件失败: ${modifyError.message}`);
                }

            } catch (error) {
                console.error('处理文件时出错:', error);
                statusEl.textContent = `错误: ${error.message}`;
                statusEl.style.color = 'var(--error-500)';
                progressBar.style.width = '0%';
                fileInfo.status = 'error';
                
                // 更新全局状态面板
                updateGlobalStatus(`处理文件 ${fileInfo.file.name} 失败`, 'error', false, error.message);
                
                // 更新下载全部按钮状态
                updateDownloadAllButton();
            }
        }

        // 修改文件
        async function modifyFile(file) {
            return new Promise(async (resolve, reject) => {
                try {
                    // 对于超大文件（大于2GB），显示特殊提示
                    if (file.size > 2 * 1024 * 1024 * 1024) {
                        console.log(`处理超大文件: ${file.name} (${(file.size / (1024 * 1024 * 1024)).toFixed(2)} GB)`);
                        updateGlobalStatus(`处理超大文件: ${file.name}`, 'info', true, `文件大小: ${(file.size / (1024 * 1024 * 1024)).toFixed(2)} GB`);
                    }
                    
                    // 对于小文件（小于100MB），使用简单方法
                    if (file.size < 100 * 1024 * 1024) {
                        const reader = new FileReader();
                        
                        reader.onload = function(e) {
                            try {
                                const buffer = e.target.result;
                                const newBuffer = new Uint8Array(buffer.byteLength + 1);
                                newBuffer.set(new Uint8Array(buffer));
                                newBuffer.set([Math.floor(Math.random() * 256)], buffer.byteLength);
                                
                                const modifiedFile = new File([newBuffer], file.name, {
                                    type: file.type,
                                    lastModified: new Date().getTime()
                                });
                                
                                resolve(modifiedFile);
                            } catch (err) {
                                reject(err);
                            }
                        };
                        
                        reader.onerror = function() {
                            reject(new Error('读取文件时出错'));
                        };
                        
                        reader.readAsArrayBuffer(file);
                    } 
                    // 对于大文件，使用分块处理
                    else {
                        updateGlobalStatus(`处理大文件: ${file.name}`, 'info', true, `使用分块处理方法`);
                        // 首先读取文件的最后部分
                        const lastChunkSize = Math.min(1024 * 1024, Math.max(1024, file.size * 0.001)); // 最后1MB或文件大小的0.1%，取较小值
                        const lastChunk = file.slice(Math.max(0, file.size - lastChunkSize));
                        
                        const reader = new FileReader();
                        reader.onload = async function(e) {
                            try {
                                const lastChunkBuffer = e.target.result;
                                
                                // 创建一个新的缓冲区，添加一个随机字节
                                const newLastChunk = new Uint8Array(lastChunkBuffer.byteLength + 1);
                                newLastChunk.set(new Uint8Array(lastChunkBuffer));
                                newLastChunk.set([Math.floor(Math.random() * 256)], lastChunkBuffer.byteLength);
                                
                                // 创建一个新文件，包含原始文件（除最后一块）和修改后的最后一块
                                const firstPart = file.slice(0, file.size - lastChunkSize);
                                
                                // 组合新文件
                                const modifiedFile = new File(
                                    [firstPart, newLastChunk], 
                                    file.name, 
                                    { type: file.type, lastModified: new Date().getTime() }
                                );
                                
                                resolve(modifiedFile);
                            } catch (err) {
                                reject(err);
                            }
                        };
                        
                        reader.onerror = function() {
                            reject(new Error('读取文件末尾时出错'));
                        };
                        
                        reader.readAsArrayBuffer(lastChunk);
                    }
                } catch (err) {
                    reject(err);
                }
            });
        }

        // 修改下载文件函数
        async function downloadFile(fileId) {
            const fileInfo = files.get(fileId);
            if (!fileInfo || !fileInfo.modifiedFile) return;

            try {
                const customSuffix = document.getElementById('customSuffix').value || '-new';
                const newFileName = `${fileInfo.file.name.replace(/\.[^/.]+$/, '')}${customSuffix}${fileInfo.file.name.match(/\.[^/.]+$/)[0]}`;

                // 更新全局状态
                updateGlobalStatus(`正在保存: ${newFileName}`, 'info', true, '文件处理中...');

                // 如果选择了目录，尝试保存到指定目录
                if (selectedDirHandle) {
                    const saved = await saveFileToDirectory(fileInfo.modifiedFile, newFileName);
                    if (saved) {
                        updateGlobalStatus(`文件已保存: ${newFileName}`, 'success', false, `保存在目录: ${selectedDirHandle.name}`);
                        return;
                    }
                }

                // 如果没有选择目录或保存失败，使用默认下载方式
                const a = document.createElement('a');
                const url = URL.createObjectURL(fileInfo.modifiedFile);
                a.href = url;
                a.download = newFileName;
                document.body.appendChild(a);
                a.click();
                
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    showToast(`文件 ${newFileName} 开始下载`);
                    updateGlobalStatus(`文件开始下载: ${newFileName}`, 'success', false);
                }, 1000);
            } catch (error) {
                console.error('下载文件时出错:', error);
                showToast(`下载文件 ${fileInfo.file.name} 失败: ${error.message}`, 'error');
                updateGlobalStatus(`下载失败: ${fileInfo.file.name}`, 'error', false, error.message);
            }
        }

        // 显示下载进度覆盖层
        function showDownloadOverlay(total) {
            const overlay = document.getElementById('downloadOverlay');
            const progressBar = document.getElementById('downloadProgressBar');
            const counter = document.getElementById('downloadCounter');
            const fileInfo = document.getElementById('downloadFileInfo');
            const subtitle = document.getElementById('downloadOverlaySubtitle');
            
            // 重置进度
            progressBar.style.width = '0%';
            counter.textContent = `0/${total}`;
            fileInfo.textContent = '准备下载...';
            subtitle.textContent = `共 ${total} 个文件等待处理`;
            
            // 显示覆盖层
            overlay.style.display = 'flex';
            
            // 禁用关闭按钮，直到处理完成
            document.getElementById('downloadOverlayClose').disabled = true;
        }
        
        // 更新下载进度
        function updateDownloadProgress(current, total, fileName, fileSize) {
            const progressBar = document.getElementById('downloadProgressBar');
            const counter = document.getElementById('downloadCounter');
            const fileInfo = document.getElementById('downloadFileInfo');
            const subtitle = document.getElementById('downloadOverlaySubtitle');
            
            // 更新进度条
            const percent = Math.round((current / total) * 100);
            progressBar.style.width = `${percent}%`;
            
            // 更新计数器
            counter.textContent = `${current}/${total}`;
            
            // 更新文件信息
            fileInfo.textContent = `当前处理: ${fileName} (${fileSize})`;
            
            // 更新副标题
            if (current === total) {
                subtitle.textContent = '所有文件处理完成!';
                document.getElementById('downloadOverlayClose').disabled = false;
            } else {
                subtitle.textContent = `正在处理第 ${current} 个文件，共 ${total} 个`;
            }
        }
        
        // 隐藏下载进度覆盖层
        function hideDownloadOverlay() {
            document.getElementById('downloadOverlay').style.display = 'none';
        }

        // 修改批量下载函数
        async function downloadAllFiles() {
            const downloadBtn = document.getElementById('downloadAllBtn');
            downloadBtn.disabled = true;
            
            try {
                const completedFiles = Array.from(files.entries())
                    .filter(([_, fileInfo]) => fileInfo.status === 'completed');
                
                if (completedFiles.length === 0) {
                    showToast('没有可下载的文件', 'error');
                    updateGlobalStatus('没有可下载的文件', 'error', false);
                    return;
                }

                // 显示下载进度覆盖层
                showDownloadOverlay(completedFiles.length);
                
                updateGlobalStatus(`开始批量下载 ${completedFiles.length} 个文件`, 'info', true, '', 0, completedFiles.length);
                const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
                const customSuffix = document.getElementById('customSuffix').value || '-new';
                let successCount = 0;

                for (let i = 0; i < completedFiles.length; i++) {
                    const [fileId, fileInfo] = completedFiles[i];
                    
                    try {
                        const newFileName = `${fileInfo.file.name.replace(/\.[^/.]+$/, '')}${customSuffix}${fileInfo.file.name.match(/\.[^/.]+$/)[0]}`;
                        const fileSizeMB = (fileInfo.file.size / (1024 * 1024)).toFixed(2);
                        const fileSizeGB = (fileInfo.file.size / (1024 * 1024 * 1024)).toFixed(2);
                        const sizeDisplay = fileSizeMB > 1024 ? `${fileSizeGB} GB` : `${fileSizeMB} MB`;
                        
                        // 更新下载进度覆盖层
                        updateDownloadProgress(i + 1, completedFiles.length, newFileName, sizeDisplay);
                        
                        updateGlobalStatus(`正在保存 (${i+1}/${completedFiles.length}): ${newFileName}`, 'info', true, `文件大小: ${sizeDisplay}`, i, completedFiles.length);

                        // 如果选择了目录，尝试保存到指定目录
                        if (selectedDirHandle) {
                            const saved = await saveFileToDirectory(fileInfo.modifiedFile, newFileName);
                            if (saved) {
                                successCount++;
                                updateGlobalStatus(`已保存 (${i+1}/${completedFiles.length}): ${newFileName}`, 'info', true, `已成功: ${successCount}`, successCount, completedFiles.length);
                                continue;
                            }
                        }

                        // 如果没有选择目录或保存失败，使用默认下载方式
                        const a = document.createElement('a');
                        const url = URL.createObjectURL(fileInfo.modifiedFile);
                        a.href = url;
                        a.download = newFileName;
                        document.body.appendChild(a);
                        a.click();
                        
                        await delay(1500);
                        URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                        successCount++;
                        updateGlobalStatus(`已下载 (${i+1}/${completedFiles.length}): ${newFileName}`, 'info', true, `已成功: ${successCount}`, successCount, completedFiles.length);
                        
                        if (i < completedFiles.length - 1) {
                            await delay(1000);
                        }
                    } catch (error) {
                        console.error(`下载文件 ${fileInfo.file.name} 时出错:`, error);
                        showToast(`下载文件 ${fileInfo.file.name} 失败: ${error.message}`, 'error');
                        updateGlobalStatus(`下载失败: ${fileInfo.file.name}`, 'error', false, error.message, successCount, completedFiles.length);
                        
                        // 更新下载进度覆盖层，标记错误
                        const fileInfo = document.getElementById('downloadFileInfo');
                        fileInfo.textContent = `错误: ${error.message}`;
                        fileInfo.style.color = 'var(--error-500)';
                    }
                }

                if (successCount > 0) {
                    showToast(`成功处理 ${successCount} 个文件`);
                    updateGlobalStatus(`批量下载完成: ${successCount}/${completedFiles.length} 个文件`, 'success', false, `所有任务已完成`, successCount, completedFiles.length);
                    
                    // 更新下载进度覆盖层
                    const fileInfo = document.getElementById('downloadFileInfo');
                    fileInfo.textContent = `成功下载 ${successCount} 个文件，共 ${completedFiles.length} 个`;
                    fileInfo.style.color = 'var(--success-500)';
                }
            } catch (error) {
                console.error('批量下载出错:', error);
                showToast('下载过程中出现错误，请重试', 'error');
                updateGlobalStatus('批量下载失败', 'error', false, error.message);
                
                // 更新下载进度覆盖层
                const fileInfo = document.getElementById('downloadFileInfo');
                fileInfo.textContent = `下载过程中出现错误: ${error.message}`;
                fileInfo.style.color = 'var(--error-500)';
            } finally {
                updateDownloadAllButton();
                // 启用关闭按钮
                document.getElementById('downloadOverlayClose').disabled = false;
            }
        }

        // 生成随机MD5
        async function calculateMd5(file) {
            return new Promise((resolve) => {
                // 使用简单的随机MD5生成方法
                // 注意：这只是模拟，并非真正的MD5计算
                const randomMd5 = Array.from(
                    { length: 32 }, 
                    () => Math.floor(Math.random() * 16).toString(16)
                ).join('');
                
                // 模拟计算需要一些时间
                setTimeout(() => resolve(randomMd5), 200);
            });
        }

        // 处理单个文件时分块读取文件，避免内存问题
        async function readFileChunks(file, chunkCallback) {
            return new Promise((resolve, reject) => {
                // 检查是否支持 File API
                if (!window.File || !window.FileReader || !window.Blob) {
                    reject(new Error('浏览器不支持文件 API'));
                    return;
                }
                
                const CHUNK_SIZE = 10 * 1024 * 1024; // 10MB 块大小
                const fileSize = file.size;
                let offset = 0;
                
                // 递归读取分块
                function readNextChunk() {
                    const reader = new FileReader();
                    
                    reader.onload = function(e) {
                        if (chunkCallback) {
                            const progress = Math.min(100, Math.round((offset / fileSize) * 100));
                            chunkCallback(e.target.result, progress);
                        }
                        
                        offset += CHUNK_SIZE;
                        
                        if (offset < fileSize) {
                            readNextChunk();
                        } else {
                            resolve();
                        }
                    };
                    
                    reader.onerror = function() {
                        reject(new Error('读取文件时出错'));
                    };
                    
                    const slice = file.slice(offset, Math.min(offset + CHUNK_SIZE, fileSize));
                    reader.readAsArrayBuffer(slice);
                }
                
                readNextChunk();
            });
        }

        // 清除所有文件
        function clearAllFiles() {
            // 清空文件列表
            files.clear();
            document.getElementById('fileList').innerHTML = '';
            
            // 禁用下载全部按钮
            document.getElementById('downloadAllBtn').disabled = true;
            
            // 更新全局状态
            updateGlobalStatus('已清除所有文件', 'info', false, '可以添加新文件');
        }

        // 初始化页面
        initializeEvents();
        
        // 页面加载完成后自动请求目录权限（立即执行）
        setTimeout(async () => {
            // 显示准备就绪状态
            updateGlobalStatus('准备就绪', 'info', false, '请添加文件或选择保存目录');
            
            // 首先尝试恢复之前保存的目录
            const restored = await tryRestoreDirectoryHandle();
            
            // 如果没有恢复成功，并且浏览器支持目录选择API，则请求新的目录
            if (!restored && 'showDirectoryPicker' in window) {
                showToast('即将请求选择保存目录权限...', 'success');
                updateGlobalStatus('正在请求目录权限...', 'info', true);
                setTimeout(() => selectSaveDirectory(), 1000);
            } else if (!('showDirectoryPicker' in window)) {
                showToast('您的浏览器不支持文件系统访问API，文件将保存到默认下载位置', 'error');
                updateGlobalStatus('无法使用本地文件系统', 'error', false, '文件将保存到默认下载位置');
            }
        }, 500);
    </script>
</body>
</html> 